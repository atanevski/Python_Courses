# -*- coding: utf-8 -*-
# Наоѓање на пресек и унија Задача 4 (3 / 3)
# Дадени се два речници, x и y, во кои клучеви се цели броеви, а вредности се листи од цели броеви. Речниците x и y се предефинирани и не треба да се менуваат. Да се напишат функции за наоѓање на пресек и унија.
#
# Функцијата за пресек треба да ги најде клучевите кои припаѓаат во двата речници, а потоа листите кои се вредности за овие клучеви да се спојат во една, при што секој елемент ќе се чува само еднаш (да нема дупликати во листите). Притоа резултантната листа да се сортира во растечки редослед.
#
# Функцијата за унија треба да ги спои двата речници, така што за клучевите кои припаѓаат само во еден од речниците, се користи листата која одговара на тој клуч во еден од речниците. Притоа од таа листа треба да се исфрлат дупликатите и потоа да сортира. За клучевите кои се наоѓаат во двата речници, листите кои се вредности за овие клучеви да се спојат во една, при што секој елемент ќе се чува само еднаш (да нема дупликати во листите). Притоа резултантната листа да се сортира во растечки редослед.
#
# Потоа треба да се повикаат овие функции со речниците x и y, резултантните речници да се трансформираат во листи од торки во облик (клуч, вредност) и добиените листи да се испечатат.
#
# Погледнете ги примерите за појаснување.
from json import dumps
import random

x = {0: [1, 1, 1, 49, 57], 2: [92, 88, 19, 49, 62], 4: [32, 19, 93, 45, 99], 6: [55, 65, 83, 36, 95],
     8: [46, 60, 48, 22, 61], 10: [43, 85, 46, 12, 92], 12: [34, 83, 70, 21, 72], 14: [12, 64, 42, 58, 51],
     16: [78, 28, 56, 100, 24], 18: [41, 49, 26, 71, 36]}
y = {0: [1, 1, 1, 52, 62], 3: [21, 64, 82, 92, 61], 6: [63, 34, 19, 29, 41], 9: [13, 13, 67, 94, 33],
     12: [22, 89, 48, 31, 60], 15: [44, 22, 89, 34, 54], 18: [52, 76, 97, 20, 39]}


# intersection and union between two dicts

def intersection(d1, d2):
    d = {}
    d1SetKeys = set(d1.keys())
    d2SetKeys = set(d2.keys())
    intersectionKeys = d1SetKeys & d2SetKeys

    for key in intersectionKeys:
        d1Temp = d1.get(key)
        sd1 = set(d1Temp)

        d2Temp = d2.get(key)
        sd2 = set(d2Temp)

        tempSet = sd1 | sd2

        tempList = list(tempSet)
        tempList.sort()

        d[key] = tempList

    return d


def union(d1, d2):
    d1SetKeys = set(d1.keys())
    d2SetKeys = set(d2.keys())

    d1UniqeKeys = d1SetKeys - d2SetKeys
    d2UniqeKeys = d2SetKeys - d1SetKeys

    inter = intersection(d1, d2)
    d = dict(inter)

    for keyD1 in d1UniqeKeys:
        toSortD1 = list(d1.get(keyD1))
        toSortD1.sort()
        d[keyD1] = toSortD1

    for keyD2 in d2UniqeKeys:
        toSortD2 = list(d2.get(keyD2))
        toSortD2.sort()
        d[keyD2] = toSortD2
    return d


if __name__ == "__main__":

    d1 = intersection(x, y)
    print(sorted(d1.items()))

    d2 = union(x, y)
    print(sorted(d2.items()))
